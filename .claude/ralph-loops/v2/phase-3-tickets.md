# Phase 3: Ticket System Core (v2)

## CRITICAL LOOP INSTRUCTIONS

**YOU ARE IN A RALPH LOOP. FOLLOW THESE RULES:**

1. **NEVER say "the next iteration will..."** - Keep working NOW
2. **NEVER end with a summary** - Summaries signal completion
3. **NEVER output the promise until ALL tasks pass validation**
4. **NEVER hallucinate column names** - Always verify from schema first

---

## Project Directory

**IMPORTANT**: All paths relative to `mhg-facilities/`. Run: `cd mhg-facilities`

---

## Prerequisites

- Phase 1 & 2 completed
- Locations and users working
- Authentication working

---

## PHASE 0: MANDATORY SCHEMA DISCOVERY

**THIS IS THE LARGEST PHASE. THOROUGH SCHEMA DISCOVERY IS CRITICAL.**

### Step 0.1: Read Ticket-Related Tables
```bash
cd mhg-facilities

# Ticket categories
grep "CREATE TABLE ticket_categories" supabase/migrations/*.sql -A 15

# Tickets (main table)
grep "CREATE TABLE tickets" supabase/migrations/*.sql -A 50

# Ticket status history
grep "CREATE TABLE ticket_status_history" supabase/migrations/*.sql -A 10

# Ticket comments
grep "CREATE TABLE ticket_comments" supabase/migrations/*.sql -A 10

# Ticket attachments
grep "CREATE TABLE ticket_attachments" supabase/migrations/*.sql -A 15

# Cost approvals
grep "CREATE TABLE cost_approvals" supabase/migrations/*.sql -A 15
```

### Step 0.2: Read Enums
```bash
grep "CREATE TYPE ticket_status" supabase/migrations/*.sql -A 15
grep "CREATE TYPE ticket_priority" supabase/migrations/*.sql -A 10
grep "CREATE TYPE approval_status" supabase/migrations/*.sql -A 5
```

### Step 0.3: Read Existing DAOs
```bash
cat src/dao/base.dao.ts
ls src/dao/*.ts
```

### Step 0.4: Document Schema

Create/update `.claude/schema-reference.md`:

```markdown
## Tickets Table
- id: UUID
- tenant_id: UUID
- ticket_number: INT (auto-generated per tenant)
- title: TEXT
- description: TEXT | null
- category_id: UUID | null (FK ticket_categories)
- location_id: UUID | null (FK locations)
- asset_id: UUID | null (FK assets)
- priority: ticket_priority ('low' | 'medium' | 'high' | 'critical')
- status: ticket_status (10 values - list them!)
- submitted_by: UUID | null (FK users)
- assigned_to: UUID | null (FK users)
- vendor_id: UUID | null (FK vendors)
- parent_ticket_id: UUID | null
- related_ticket_ids: UUID[]
- merged_into_ticket_id: UUID | null
- is_duplicate: BOOLEAN
- estimated_cost: DECIMAL
- approved_cost: DECIMAL
- actual_cost: DECIMAL
- is_warranty_claim: BOOLEAN
- due_date: TIMESTAMPTZ
- acknowledged_at, approved_at, started_at, completed_at, verified_at, closed_at
- is_emergency: BOOLEAN
- requires_approval: BOOLEAN
- created_at, updated_at, deleted_at

## Ticket Statuses (EXACT VALUES)
'submitted', 'acknowledged', 'needs_approval', 'approved',
'in_progress', 'completed', 'verified', 'closed', 'rejected', 'on_hold'

## Ticket Priorities (EXACT VALUES)
'low', 'medium', 'high', 'critical'
```

---

## Anti-Hallucination Rules

| Check | Before Writing |
|-------|---------------|
| Column exists? | `grep "column_name" supabase/migrations/*.sql` |
| Enum value valid? | Check CREATE TYPE statement |
| FK references correct table? | Check REFERENCES clause |
| Column is nullable? | Check for NOT NULL constraint |

---

## Task 1: Ticket Category DAO & Service

### 1.1: Verify Columns
```bash
grep "CREATE TABLE ticket_categories" supabase/migrations/*.sql -A 15
```

### 1.2: Create DAO

**File:** `src/dao/ticket-category.dao.ts`

Use BaseDAO pattern. Only use verified columns.

### 1.3: Create Service

**File:** `src/services/ticket-category.service.ts`

---

## Task 2: Ticket DAO

### 2.1: Create DAO

**File:** `src/dao/ticket.dao.ts`

**Methods (derive from actual schema):**
- `findByStatus(status)` - Filter by status column
- `findByLocation(locationId)` - Filter by location_id
- `findByAssignee(userId)` - Filter by assigned_to
- `findBySubmitter(userId)` - Filter by submitted_by
- `findWithRelations(id)` - Join category, location, asset, assigned user
- `findOverdue()` - Where due_date < now AND status not closed

---

## Task 3: Ticket Service

### 3.1: Create Service

**File:** `src/services/ticket.service.ts`

**Status Transitions (enforce valid state machine):**
```
submitted → acknowledged, rejected
acknowledged → needs_approval, in_progress, assigned
needs_approval → approved, rejected
approved → in_progress, assigned
in_progress → completed, on_hold
on_hold → in_progress
completed → verified, reopened (back to in_progress)
verified → closed
```

**Key Methods:**
- `createTicket()` - Ticket number is auto-generated by DB trigger
- `updateStatus()` - Validate transition is allowed
- `assignTicket()` - Set assigned_to, trigger notification
- `assignToVendor()` - Set vendor_id

---

## Task 4: Ticket Comment Service

### 4.1: Verify Schema
```bash
grep "CREATE TABLE ticket_comments" supabase/migrations/*.sql -A 10
```

### 4.2: Create DAO & Service

**Files:**
- `src/dao/ticket-comment.dao.ts`
- `src/services/ticket-comment.service.ts`

---

## Task 5: Ticket Attachment Service

### 5.1: Verify Schema
```bash
grep "CREATE TABLE ticket_attachments" supabase/migrations/*.sql -A 15
```

Note the `attachment_type` CHECK constraint values!

### 5.2: Create DAO & Service

**Files:**
- `src/dao/ticket-attachment.dao.ts`
- `src/services/ticket-attachment.service.ts`

---

## Task 6: Cost Approval Service

### 6.1: Verify Schema
```bash
grep "CREATE TABLE cost_approvals" supabase/migrations/*.sql -A 15
```

### 6.2: Create DAO & Service

**Files:**
- `src/dao/cost-approval.dao.ts`
- `src/services/cost-approval.service.ts`

---

## Task 7: Ticket API Routes

### 7.1: Main Ticket Routes

**Files:**
- `src/app/api/tickets/route.ts` - GET (list), POST (create)
- `src/app/api/tickets/[id]/route.ts` - GET, PATCH
- `src/app/api/tickets/[id]/status/route.ts` - PATCH
- `src/app/api/tickets/[id]/assign/route.ts` - POST
- `src/app/api/tickets/[id]/comments/route.ts` - GET, POST
- `src/app/api/tickets/[id]/attachments/route.ts` - GET, POST
- `src/app/api/tickets/[id]/approval/route.ts` - GET, POST, PATCH
- `src/app/api/tickets/check-duplicate/route.ts` - POST

### 7.2: Category Routes

**Files:**
- `src/app/api/ticket-categories/route.ts`
- `src/app/api/ticket-categories/[id]/route.ts`

---

## Task 8: Ticket List Page

**File:** `src/app/(dashboard)/tickets/page.tsx`

**Features:**
- Kanban view by status (use @hello-pangea/dnd)
- List view option
- Filters: status, priority, location, assignee
- Search
- "Create Ticket" button

**Install dependency:**
```bash
npm install @hello-pangea/dnd
```

---

## Task 9: Ticket Creation Flow

**Files:**
- `src/app/(dashboard)/tickets/new/page.tsx`
- `src/components/tickets/ticket-form.tsx`

---

## Task 10: Ticket Detail Page

**File:** `src/app/(dashboard)/tickets/[id]/page.tsx`

---

## Task 11: Status Components

**Files:**
- `src/components/tickets/status-badge.tsx`
- `src/components/tickets/status-timeline.tsx`
- `src/components/tickets/status-actions.tsx`

---

## Task 12: Assignment Components

**Files:**
- `src/components/tickets/assign-modal.tsx`
- `src/components/tickets/assign-vendor-modal.tsx`

---

## Task 13: Comments & Attachments

**Files:**
- `src/components/tickets/comment-list.tsx`
- `src/components/tickets/comment-form.tsx`
- `src/components/tickets/attachment-gallery.tsx`
- `src/components/tickets/attachment-upload.tsx`

---

## Task 14: Cost Approval Components

**Files:**
- `src/components/tickets/cost-approval-form.tsx`
- `src/components/tickets/approval-status.tsx`
- `src/app/(dashboard)/approvals/page.tsx`

---

## Task 15: Validation Schemas

**File:** `src/lib/validations/ticket.ts`

**Use EXACT enum values:**
```typescript
export const ticketStatusSchema = z.enum([
  'submitted', 'acknowledged', 'needs_approval', 'approved',
  'in_progress', 'completed', 'verified', 'closed', 'rejected', 'on_hold'
])

export const ticketPrioritySchema = z.enum([
  'low', 'medium', 'high', 'critical'
])
```

---

## Task 16: Ticket Hooks

**File:** `src/hooks/use-tickets.ts`

TanStack Query hooks for ticket operations.

---

## Validation After Each Task

```bash
npm run type-check  # MUST pass
npm run lint        # MUST pass
npm run build       # MUST pass
```

---

## Completion Criteria

1. [ ] Schema fully documented
2. [ ] Staff can create tickets
3. [ ] Duplicate detection works
4. [ ] Ticket list shows all tickets with filters
5. [ ] Kanban drag-drop changes status
6. [ ] Ticket detail shows full info
7. [ ] Status transitions enforce workflow
8. [ ] Comments support internal/public
9. [ ] Attachments upload to storage
10. [ ] Cost approval workflow works
11. [ ] Ticket number auto-increments
12. [ ] All forms validated
13. [ ] UI responsive
14. [ ] `npm run build` passes

**ONLY when ALL criteria met, output:**
```
<promise>PHASE_3_COMPLETE</promise>
```

---

## Large Phase Warning

This is the largest phase. Consider breaking into sub-phases:

**Sub-phase 3a:** Tasks 1-6 (DAOs and Services)
**Sub-phase 3b:** Task 7 (API Routes)
**Sub-phase 3c:** Tasks 8-16 (UI)

Commit after each sub-phase.

---

## START HERE

1. Run schema discovery (Phase 0) - **DO NOT SKIP**
2. Document ALL ticket-related tables
3. Begin Task 1
4. Validate after each task
5. Commit frequently
6. Continue until complete
